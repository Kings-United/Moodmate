{"ast":null,"code":"import{useState,useEffect}from'react';import{journalAPI}from'../services/api';export const useJournal=()=>{const[entries,setEntries]=useState([]);const[loading,setLoading]=useState(true);const[error,setError]=useState(null);const fetchEntries=async function(){let limit=arguments.length>0&&arguments[0]!==undefined?arguments[0]:50;try{setLoading(true);setError(null);const response=await journalAPI.getEntries(limit);setEntries(response.data.entries);}catch(error){var _error$response,_error$response$data;setError(((_error$response=error.response)===null||_error$response===void 0?void 0:(_error$response$data=_error$response.data)===null||_error$response$data===void 0?void 0:_error$response$data.error)||'Failed to fetch entries');}finally{setLoading(false);}};const createEntry=async entryData=>{try{const response=await journalAPI.createEntry(entryData);const newEntry=response.data.entry;setEntries(prev=>[newEntry,...prev]);return newEntry;}catch(error){var _error$response2,_error$response2$data;throw new Error(((_error$response2=error.response)===null||_error$response2===void 0?void 0:(_error$response2$data=_error$response2.data)===null||_error$response2$data===void 0?void 0:_error$response2$data.error)||'Failed to create entry');}};const updateEntry=async(id,entryData)=>{try{const response=await journalAPI.updateEntry(id,entryData);const updatedEntry=response.data.entry;setEntries(prev=>prev.map(entry=>entry.id===id?updatedEntry:entry));return updatedEntry;}catch(error){var _error$response3,_error$response3$data;throw new Error(((_error$response3=error.response)===null||_error$response3===void 0?void 0:(_error$response3$data=_error$response3.data)===null||_error$response3$data===void 0?void 0:_error$response3$data.error)||'Failed to update entry');}};const deleteEntry=async id=>{try{await journalAPI.deleteEntry(id);setEntries(prev=>prev.filter(entry=>entry.id!==id));}catch(error){var _error$response4,_error$response4$data;throw new Error(((_error$response4=error.response)===null||_error$response4===void 0?void 0:(_error$response4$data=_error$response4.data)===null||_error$response4$data===void 0?void 0:_error$response4$data.error)||'Failed to delete entry');}};useEffect(()=>{fetchEntries();},[]);return{entries,loading,error,fetchEntries,createEntry,updateEntry,deleteEntry};};","map":{"version":3,"names":["useState","useEffect","journalAPI","useJournal","entries","setEntries","loading","setLoading","error","setError","fetchEntries","limit","arguments","length","undefined","response","getEntries","data","_error$response","_error$response$data","createEntry","entryData","newEntry","entry","prev","_error$response2","_error$response2$data","Error","updateEntry","id","updatedEntry","map","_error$response3","_error$response3$data","deleteEntry","filter","_error$response4","_error$response4$data"],"sources":["C:/Users/Mayur/OneDrive/Desktop/Moodmate/Frontend/src/hooks/useJournal.js"],"sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { journalAPI } from '../services/api';\r\n\r\nexport const useJournal = () => {\r\n    const [entries, setEntries] = useState([]);\r\n    const [loading, setLoading] = useState(true);\r\n    const [error, setError] = useState(null);\r\n\r\n    const fetchEntries = async (limit = 50) => {\r\n        try {\r\n            setLoading(true);\r\n            setError(null);\r\n            const response = await journalAPI.getEntries(limit);\r\n            setEntries(response.data.entries);\r\n        } catch (error) {\r\n            setError(error.response?.data?.error || 'Failed to fetch entries');\r\n        } finally {\r\n            setLoading(false);\r\n        }\r\n    };\r\n\r\n    const createEntry = async (entryData) => {\r\n        try {\r\n            const response = await journalAPI.createEntry(entryData);\r\n            const newEntry = response.data.entry;\r\n            setEntries(prev => [newEntry, ...prev]);\r\n            return newEntry;\r\n        } catch (error) {\r\n            throw new Error(error.response?.data?.error || 'Failed to create entry');\r\n        }\r\n    };\r\n\r\n    const updateEntry = async (id, entryData) => {\r\n        try {\r\n            const response = await journalAPI.updateEntry(id, entryData);\r\n            const updatedEntry = response.data.entry;\r\n            setEntries(prev => prev.map(entry =>\r\n                entry.id === id ? updatedEntry : entry\r\n            ));\r\n            return updatedEntry;\r\n        } catch (error) {\r\n            throw new Error(error.response?.data?.error || 'Failed to update entry');\r\n        }\r\n    };\r\n\r\n    const deleteEntry = async (id) => {\r\n        try {\r\n            await journalAPI.deleteEntry(id);\r\n            setEntries(prev => prev.filter(entry => entry.id !== id));\r\n        } catch (error) {\r\n            throw new Error(error.response?.data?.error || 'Failed to delete entry');\r\n        }\r\n    };\r\n\r\n    useEffect(() => {\r\n        fetchEntries();\r\n    }, []);\r\n\r\n    return {\r\n        entries,\r\n        loading,\r\n        error,\r\n        fetchEntries,\r\n        createEntry,\r\n        updateEntry,\r\n        deleteEntry\r\n    };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}